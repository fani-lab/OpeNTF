dim: 128 # embedding dim. it matters for skill vectors if the skill set is small (e.g., in imdb or gith) or large (e.g., in dblp or uspt)

model:
  batch_size: 128 # batch_size for loaders
  epochs: 100 # num max epochs
  ns: 5 # number of negative samples
  lr: 0.001 #learning rate
  save_per_epoch:

  # Quoc V. Le, Tomás Mikolov: Distributed Representations of Sentences and Documents. ICML 2014: 1188-1196
  d2v: # we use gensim
    embtype: skill # skill, member, skillmember, skilltime
    dm: 1 # training algorithm. 1: distributed memory (PV-DM), 0: distributed bag of words (PV-DBOW)
    # NOTE: As the input is a skill subset, so either the sum/avg of skill vectors individually >> embtype = 'skill' or 'joint' and  dbow_words = True
    # OR the team vecs when the words are only skills. So, embtype = 'skill' and  dbow_words = False
    # let's remove this and do for always
    # dbow_words: True # train word-vectors in skip-gram fashion; 0: no (default, faster), 1: yes.
    w: 5 # cooccurrence window. In OpeNTF (for teams), depends on the average team size (n_members) plus n_skills per teams
    d: ${dim}
    e: ${model.epochs}
    lr: ${model.lr}

  gnn:
    graph:
      structure: #hydra doesn't understand tuple. So, inside code, explicit cast to tuple(...)
        [member, m] #homo
        #[[[skill, to, member]], sm) #hetero
        #[[[skill, to, team], [member, to, team]], stm]
        #[[[skill, to, team], [member, to, team], [loc, to, team]], stml]
        #[[[skill, to, skill], [skill, to, team], [member, to, team], [loc, to, team]], sstml]

      supervision_edge_types:
        # if not set, it will take all the forward edge_types as supervision edges
        #([('member', 'to', 'team')], 'stm')

      dup_edge: #https://pytorch-geometric.readthedocs.io/en/2.6.1/generated/torch_geometric.transforms.ToUndirected.html
        # if not set, keep the duplicates, else: merged by 'add', 'mean', 'min', 'max', or 'mul' >> for now, a single edge feature of value 1, so, mean, max, min should have all same effect
        add
        #mean
        #min
        #max
        #mul
      pre: # if set, use pretrained D2v vectors as initial node features of graph data
        #../output/{domain}/toy.{data}/d8.e100.w10.d2v.dm1.skillmember  # skill, member, team
        #../output/{domain}/toy.{data}/d8.e100.w10.d2v.dm1.skill  # skill, team
        #../output/uspt/toy.patent.tsv/d9.e100.w10.d2v.dm1.skill  # if not exists, train from scratch!
    pytorch: #will be set dynamically in ./src/main.py from root ./config.yml
    save_per_epochs: ${model.save_per_epoch}
    model: #dummy tag. don't worry or touch it.

    #Grover, Aditya, and Jure Leskovec. "node2vec: Scalable feature learning for networks." Proceedings of the 22nd ACM SIGKDD international conference on Knowledge discovery and data mining. 2016.
    #p: Return parameter, controls likelihood of revisiting the previous node. high p → discourages going back, low p → encourages backtracking
    #q: In-out (exploration) parameter, controls likelihood of visiting distant vs nearby nodes. high q → BFS-like (stick to local neighborhood), low q → DFS-like (explore outward)
    #p q	Behavior
    #1 1	Unbiased random walk (vanilla DeepWalk)
    #1 0.5	DFS-like (explore outward, communities)
    #1 2	BFS-like (stay local, structural roles)
    #0.2 4	Very local walks
    #4 0.25	Very exploratory
    n2v:
      w: ${model.d2v.w}
      d: ${dim}
      e: ${model.epochs}
      b: ${model.batch_size}
      lr: ${model.lr}
      ns: ${model.ns}
      wl: 5  #walk_length
      wn: 10 #walks_per_node
      p: 1.0
      q: 1.0

    #Thomas N. Kipf, Max Welling: Semi-Supervised Classification with Graph Convolutional Networks. ICLR (Poster) 2017
    gcn:
      hd: 10 # hidden dimension? isn't the same as emb dim here?

    #Hamilton, Will, Zhitao Ying, and Jure Leskovec. "Inductive representation learning on large graphs." NIPS (2017).
    gs:
      d: ${dim}
      e: ${model.epochs}
      b: ${model.batch_size}
      lr: ${model.lr}
      ns: ${model.ns}
      ah: 2 # number of attention heads (if applicable)
      nn: [30, 20] # number of neighbors in each hop ([20, 10] -> 20 neighbors in first hop, 10 neighbors in second hop)

#  'gnn.gin': {
#      'e': 100,
#      'b': 128,
#      'd': 8,
#      'ns' : 5,
#      'h': 2,
#      'nn': [30, 20],
#      'graph_types': 'stm',
#      'agg': 'mean',
#      'dir': False,
#  },
#  'gnn.gat': {
#      'e': 100,
#      'b': 128,
#      'd': 8,
#      'ns' : 5,
#      'h': 2,
#      'nn': [30, 20],
#      'graph_types': 'stm',
#      'agg': 'mean',
#      'dir': False,
#  },
#  'gnn.gatv2': {
#      'e': 100,
#      'b': 128,
#      'd': 8,
#      'ns' : 5,
#      'h': 2,
#      'nn': [20, 10],
#      'graph_types': 'stm',
#      'agg': 'mean',
#      'dir': False,
#  },
#  'gnn.han': {
#      'e': 100,
#      'b': 128,
#      'd': 8,
#      'ns' : 5,
#      'h': 2,
#      'nn': [30, 20],
#      'graph_types': 'stm',
#      'agg': 'mean',
#      'dir': False,
#      'metapaths':{
#          'sm': [[('skill', 'to', 'member'), ('member', 'rev_to', 'skill')]],
#          'stm': [
#              [('member', 'to', 'team'), ('team', 'rev_to', 'skill'), ('skill', 'to', 'team'), ('team', 'rev_to', 'member')],
#              [('skill', 'to', 'team'), ('team', 'rev_to', 'member'), ('member', 'to', 'team'), ('team', 'rev_to', 'skill')],
#              [('member', 'to', 'team'), ('team', 'rev_to', 'member')],
#              [('skill', 'to', 'team'), ('team', 'rev_to', 'skill')],
#          ],
#          'stml': [
#              [('member', 'to', 'team'), ('team', 'rev_to', 'loc'), ('loc', 'to', 'team'), ('team', 'rev_to', 'member')],
#              [('skill', 'to', 'team'), ('team', 'rev_to', 'member'), ('member', 'to', 'team'), ('team', 'rev_to', 'skill')],
#              [('member', 'to', 'team'), ('team', 'rev_to', 'member')],
#              [('skill', 'to', 'team'), ('team', 'rev_to', 'skill')],
#          ],
#          # added one extra e-e connection in the middle
#          # 'sm.en': [[('skill', 'to', 'skill'), ('skill', 'to', 'member'), ('member', 'to', 'member'), ('member', 'rev_to', 'skill'), ('skill', 'to', 'skill')]],
#          'sm.en': [[('skill', 'to', 'skill'), ('skill', 'to', 'member'), ('member', 'rev_to', 'skill'), ('skill', 'to', 'skill')]],
#          'stm.en': [
#              [('member', 'to', 'team'), ('team', 'rev_to', 'skill'), ('skill', 'to', 'team'), ('team', 'rev_to', 'member')],
#              [('skill', 'to', 'team'), ('team', 'rev_to', 'member'), ('member', 'to', 'team'), ('team', 'rev_to', 'skill')],
#              [('member', 'to', 'team'), ('team', 'rev_to', 'member')],
#              [('skill', 'to', 'team'), ('team', 'rev_to', 'skill')],
#              # repeating the same set of metapaths with additional s-s or e-e connections
#              # [('member', 'to', 'member'), ('member', 'to', 'team'), ('team', 'rev_to', 'skill'), ('skill', 'to', 'team'), ('team', 'rev_to', 'member'), ('member', 'to', 'member')],
#              # [('skill', 'to', 'skill'), ('skill', 'to', 'team'), ('team', 'rev_to', 'member'), ('member', 'to', 'team'), ('team', 'rev_to', 'skill'), ('skill', 'to', 'skill')],
#              # [('member', 'to', 'member'), ('member', 'to', 'team'), ('team', 'rev_to', 'member'), ('member', 'to', 'member')],
#              # [('skill', 'to', 'skill'), ('skill', 'to', 'team'), ('team', 'rev_to', 'skill'), ('skill', 'to', 'skill')],
#          ]
#      }
#  },
#  'gnn.gine': {
#      'e': 100,
#      'b': 128,
#      'd': 8,
#      'ns' : 5,
#      'h': 2,
#      'nn': [30, 20],
#      'graph_types': 'stm',
#      'agg': 'mean',
#      'dir': False,
#  },
#  'gnn.lant': {
#      'e': 100,
#      'b': 128,
#      'd': 8,
#      'ns' : 5,
#      'h': 2,
#      'nn': [30, 20],
#      'graph_types': 'stm',
#      'agg': 'mean',
#      'dir': False,
#  },
#  'gnn.m2v': {
#      'graph_types':'stm', # this value will be changed during runtime in each loop according to the graph_type and then be used in the embedding_output var
#      'metapath' : {
#          'sm' : [
#              ('member','rev_to','skill'),
#              ('skill', 'to', 'member'),
#          ],
#          'stm' : [
#              ('member','to','team'),
#              ('team', 'rev_to', 'skill'),
#              ('skill','to','team'),
#              ('team', 'rev_to', 'member'),
#          ],
#          'stml' : [
#              ('member','to','team'),
#              ('team', 'rev_to', 'loc'),
#              ('loc','to','team'),
#              ('team', 'rev_to', 'member'),
#          ],
#
#          # experimental section
#          'sm.en' : [
#              ('member','rev_to','skill'),
#              # ('skill', 'to', 'skill'),           # additional s-s connection
#              ('skill', 'to', 'member'),
#          ],
#          'stm.en' : [
#              ('member','to','team'),
#              ('team', 'rev_to', 'skill'),
#              # ('skill', 'to', 'skill'),           # additional s-s connection
#              ('skill','to','team'),
#              ('team', 'rev_to', 'member'),
#          ],
#      },
#      'walk_length': 10,
#      'context_size': 10,
#      'walks_per_node': 20,
#      'ns' : 5,
#      'd': 8,
#      'b': 128,
#      'e': 100,
#  },
#},